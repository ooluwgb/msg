#!/usr/bin/env python3
"""
Dependency Installer (install_deps.py)

Reads dependencies and versions from requirement.json, installs/upgrades 
Python packages via pip, and handles NLTK data download and extraction.
Returns:
    0: Success (All required packages and data installed/up-to-date)
    1: Fatal Error (e.g., pip failure, essential package missing, 'version_update_required: true' failed)
    2: Non-Fatal Warning (e.g., optional package failure, 'version_update_required: false' failed, minor NLTK issues)
"""
import sys
import json
import subprocess
import os
import zipfile
from pathlib import Path
from typing import Dict, List, Any, Tuple

# --- Configuration & Paths ---
BASE_DIR = Path(__file__).resolve().parent.parent
REQUIREMENTS_FILE = BASE_DIR / "config" / "requirement.json"
# NLTK data location in hidden directory within project
NLTK_DATA_PATH = BASE_DIR / ".nltk_data"
# Ensure NLTK uses our custom path for data files
os.environ['NLTK_DATA'] = str(NLTK_DATA_PATH)


# --- Helper Functions ---

def print_step(message: str) -> None:
    """Prints a stylized step header."""
    print(f"\n\033[1m==> {message}\033[0m")


def is_in_virtual_environment() -> bool:
    """Detect if we're running in a virtual environment."""
    return (hasattr(sys, 'real_prefix') or 
            (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix) or
            os.environ.get('VIRTUAL_ENV') is not None)


def is_externally_managed_environment() -> bool:
    """Detect if Python environment is externally managed (PEP 668)."""
    # Check for EXTERNALLY-MANAGED file which indicates PEP 668 compliance
    import sysconfig
    stdlib_dir = Path(sysconfig.get_path('stdlib'))
    externally_managed_file = stdlib_dir / 'EXTERNALLY-MANAGED'
    return externally_managed_file.exists()


def get_pip_install_args() -> List[str]:
    """Get appropriate pip install arguments based on environment."""
    base_args = [sys.executable, '-m', 'pip', 'install', '--upgrade']
    
    if is_in_virtual_environment():
        return base_args
    elif is_externally_managed_environment():
        return base_args + ['--break-system-packages']
    else:
        return base_args + ['--user']


def load_requirements() -> Tuple[Dict[str, Any], int]:
    """Loads and validates the requirements JSON file."""
    if not REQUIREMENTS_FILE.exists():
        print(f"‚ùå FATAL: Requirement file not found at {REQUIREMENTS_FILE}")
        return {}, 1
        
    try:
        with open(REQUIREMENTS_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
            
        if not isinstance(data, dict):
            raise ValueError("Invalid JSON format (expected root object).")
            
        return data, 0
    except Exception as e:
        print(f"‚ùå FATAL: Failed to load/parse {REQUIREMENTS_FILE.name}: {e}")
        return {}, 1


def compare_versions(current: str, required: str) -> bool:
    """Returns True if the current version is strictly LESS than the required version."""
    if not current or current == "0.0.0":
        return True # Package not installed or unknown version, needs installation
    if not required:
        return False # No required version specified, assume current is fine
        
    # Simple version comparison by splitting and comparing tuples
    def parse_version(v):
        # Remove any suffixes like '-beta', '-ayodele' and split by dots
        clean_version = v.split('-')[0]
        parts = []
        for part in clean_version.split('.'):
            try:
                parts.append(int(part))
            except ValueError:
                # If we can't parse as int, treat as 0 for comparison
                parts.append(0)
        return tuple(parts)
    
    try:
        return parse_version(current) < parse_version(required)
    except Exception:
        # If version comparison fails, assume upgrade needed
        return True


def check_package_installed(package_name: str) -> Tuple[bool, str]:
    """Check if a package is installed and return (is_installed, version)."""
    try:
        result = subprocess.run(
            [sys.executable, '-m', 'pip', 'show', package_name],
            capture_output=True, text=True, check=False
        )
        
        if result.returncode == 0:
            # Package is installed, extract version
            for line in result.stdout.splitlines():
                if line.startswith("Version:"):
                    version = line.split(":", 1)[1].strip()
                    return True, version
            # Package shown but no version found (edge case)
            return True, "unknown"
        else:
            # Package not installed
            return False, "0.0.0"
            
    except Exception as e:
        print(f"‚ö†Ô∏è  Warning: Failed to check package {package_name}: {e}")
        # Assume not installed if check fails
        return False, "0.0.0"


# --- Step 1: Python Package Management (pip) ---

def manage_pip_packages(packages: List[Dict[str, Any]]) -> int:
    """Checks and installs/upgrades packages only if necessary."""
    print_step("Installing Python Packages via pip")
    
    if is_externally_managed_environment() and not is_in_virtual_environment():
        print("‚ö†Ô∏è  Warning: Using externally-managed Python environment.")
        print("   Installing with --break-system-packages flag.")
        print("   Consider using a virtual environment for better isolation.")
    
    # Track non-fatal (optional or version_update_required: false) failures
    warning_count = 0
    # List of packages that NEED installation/upgrade and their required failure mode
    packages_to_install: List[Tuple[str, bool]] = [] # (pkg_name_spec, is_fatal_if_failed)
    
    for pkg in packages:
        name = pkg.get('name')
        required_version = pkg.get('version')
        is_optional = pkg.get('optional', False)
        # New control attribute: True means failure is fatal (Exit 1), False means non-fatal (Exit 2)
        is_update_fatal = pkg.get('version_update_required', True)
        
        if not name or not required_version:
            continue
            
        try:
            # Check if package is installed and get version
            is_installed, current_version = check_package_installed(name)
            
            if not is_installed:
                print(f"  ‚Ä¢ Installing {name} (not currently installed)...")
                package_spec = f"{name}=={required_version}"
                # Determine the failure mode for this specific installation
                if is_optional:
                    packages_to_install.append((package_spec, False))
                else:
                    packages_to_install.append((package_spec, is_update_fatal))
            elif compare_versions(current_version, required_version):
                print(f"  ‚Ä¢ Upgrading {name} ({current_version} < {required_version})...")
                package_spec = f"{name}=={required_version}"
                # Determine the failure mode for this specific upgrade
                if is_optional:
                    packages_to_install.append((package_spec, False))
                else:
                    packages_to_install.append((package_spec, is_update_fatal))
            else:
                # User is up-to-date or ahead - skip
                print(f"  ‚Ä¢ {name} is up-to-date ({current_version} vs required {required_version}).")
                
        except Exception as e:
            print(f"‚ùå FATAL: Failed to check package {name}: {e}")
            return 1 # Fatal error if we can't even check the package
    
    # 2. Perform installation/upgrade for packages that need it
    if packages_to_install:
        
        install_specs = [spec for spec, _ in packages_to_install]
        install_cmd = get_pip_install_args() + install_specs
        
        if is_in_virtual_environment():
            env_type = "virtual environment"
        elif is_externally_managed_environment():
            env_type = "externally-managed environment"
        else:
            env_type = "user environment"
            
        print(f"\n  Installing to {env_type}...")
        
        try:
            print("  Executing batched installation...")
            # Run pip installation
            result = subprocess.run(
                install_cmd, 
                check=True,
                capture_output=True,
                text=True
            )
            print("  ‚úÖ Batched installation complete.")
        except subprocess.CalledProcessError as e:
            # If user install failed and not in venv and not externally managed, try system install as fallback
            if (not is_in_virtual_environment() and 
                not is_externally_managed_environment() and 
                '--user' in install_cmd):
                print("  ‚ö†Ô∏è  User installation failed, trying system installation as fallback...")
                try:
                    fallback_cmd = [sys.executable, '-m', 'pip', 'install', '--upgrade'] + install_specs
                    subprocess.run(fallback_cmd, check=True, capture_output=True, text=True)
                    print("  ‚úÖ Fallback system installation successful.")
                except subprocess.CalledProcessError as fallback_error:
                    # Both failed, check criticality
                    print(f"\n‚ùå Both user and system pip installation failed.")
                    print(f"   Error: {fallback_error.stderr.strip() if fallback_error.stderr else str(fallback_error)}")
                    is_any_fatal = any(is_fatal for _, is_fatal in packages_to_install)
                    return 1 if is_any_fatal else 2
            else:
                # Check the error against the required severity
                print(f"\n‚ùå Pip installation failed.")
                print(f"   Error: {e.stderr.strip() if e.stderr else str(e)}")
                
                # Find the most critical failure mode among the packages we tried to install
                is_any_fatal = any(is_fatal for _, is_fatal in packages_to_install)

                if is_any_fatal:
                     print("   FATAL: At least one critical package installation failed.")
                     return 1
                else:
                     print("   NON-FATAL: Only optional package installations failed.")
                     return 2
            
        except Exception as e:
            print(f"\n‚ùå FATAL: General error during pip installation: {e}")
            return 1
    else:
        print("  ‚ÑπÔ∏è  All required packages are already up-to-date.")
            
    return 2 if warning_count > 0 else 0


# --- Step 2: NLTK Data Management ---

def extract_nltk_zips() -> int:
    """Extracts all zip files within the NLTK_DATA_PATH to make resources accessible."""
    print_step("Extracting NLTK Data Archives")
    
    if not NLTK_DATA_PATH.exists():
        print("‚ÑπÔ∏è  NLTK data directory not found. Skipping extraction.")
        return 0

    extracted_count = 0
    warning_count = 0
    
    for item in NLTK_DATA_PATH.rglob('*'):
        if item.is_file() and item.suffix == '.zip':
            
            target_dir = item.parent 
            stem_name = item.stem
            
            if (target_dir / stem_name).exists():
                continue

            try:
                print(f"  ‚Ä¢ Extracting {item.name}...")
                with zipfile.ZipFile(item, 'r') as zip_ref:
                    zip_ref.extractall(target_dir)
                extracted_count += 1
            except Exception as e:
                print(f"‚ö†Ô∏è  WARNING: Failed to extract {item.name}: {e}")
                warning_count += 1

    if extracted_count > 0:
        print(f"  ‚úÖ Successfully extracted {extracted_count} new archive(s).")
    elif warning_count == 0:
        print("  ‚ÑπÔ∏è  All NLTK archives already extracted.")
        
    return 2 if warning_count > 0 else 0


def manage_nltk_data(resources: List[Dict[str, Any]]) -> int:
    """Downloads required NLTK resources and triggers zip extraction."""
    print_step("Downloading NLTK Data Resources")
    
    NLTK_DATA_PATH.mkdir(parents=True, exist_ok=True)
    
    try:
        import nltk 
        
        warning_count = 0
        
        for res in resources:
            resource_name = res.get('resource')
            is_optional = res.get('optional', False)
            
            if not resource_name:
                continue
                
            try:
                # Check if resource is already found/downloaded
                nltk.data.find(resource_name)
                print(f"  ‚Ä¢ {resource_name} data is already present.")
            except LookupError:
                 try:
                    # Attempt download if not found
                    print(f"  ‚Ä¢ Downloading {resource_name}...")
                    nltk.download(resource_name, download_dir=str(NLTK_DATA_PATH), quiet=True)
                    print(f"  ‚úÖ {resource_name} downloaded.")
                 except Exception as e:
                    if is_optional:
                        print(f"‚ö†Ô∏è  WARNING: Failed to download optional resource {resource_name}: {e}")
                        warning_count += 1
                    else:
                        print(f"‚ùå FATAL: Failed to download required resource {resource_name}.")
                        return 1
            except Exception as e:
                 if is_optional:
                    print(f"‚ö†Ô∏è  WARNING: Error checking optional resource {resource_name}: {e}")
                    warning_count += 1
                 else:
                    print(f"‚ùå FATAL: Error checking required resource {resource_name}: {e}")
                    return 1
        
        # 2. Extract zips
        extract_code = extract_nltk_zips()
        
        if extract_code == 2 or warning_count > 0:
             return 2 
        return 0 
        
    except ImportError:
        print("‚ùå FATAL: NLTK Python package is missing. Cannot manage data resources.")
        return 1
    except Exception as e:
        print(f"‚ùå FATAL: Unhandled error in NLTK management: {e}")
        return 1


# --- Main Execution ---

if __name__ == "__main__":
    
    final_exit_code = 0
    
    # 1. Load Requirements
    requirements, code = load_requirements()
    if code != 0:
        print("‚ùå FATAL: Cannot proceed without valid requirements configuration.")
        sys.exit(1)
        
    python_packages = requirements.get('python_packages', [])
    nltk_data = requirements.get('nltk_data', [])
    
    # 2. Manage Python Packages (CRITICAL STEP)
    print("üîß Installing Python dependencies...")
    pip_code = manage_pip_packages(python_packages)
    
    if pip_code == 1:
        print("\n‚ùå CRITICAL FAILURE: Essential Python packages could not be installed.")
        print("   Installation cannot continue without these dependencies.")
        sys.exit(1) 
    elif pip_code == 2:
        print("\n‚ö†Ô∏è  WARNING: Some optional packages failed to install, but continuing...")
        final_exit_code = 2
    else:
        print("\n‚úÖ All Python packages successfully installed/verified.")

    # 3. Manage NLTK Data (only if NLTK was successfully installed)
    # Check if 'nltk' was required and successfully installed
    nltk_required = any(pkg['name'].lower() == 'nltk' for pkg in python_packages)
    
    if nltk_required:
        print("üîß Setting up NLTK data resources...")
        
        # Verify NLTK is actually importable before proceeding
        try:
            import nltk
        except ImportError:
            print("‚ùå FATAL: NLTK package is required but not available after installation.")
            sys.exit(1)
            
        nltk_code = manage_nltk_data(nltk_data)
        
        if nltk_code == 1:
            print("\n‚ùå CRITICAL FAILURE: Essential NLTK data could not be downloaded.")
            print("   Installation cannot continue without these language resources.")
            sys.exit(1) 
        elif nltk_code == 2:
            print("\n‚ö†Ô∏è  WARNING: Some optional NLTK data failed, but continuing...")
            if final_exit_code == 0:
                final_exit_code = 2
        else:
            print("\n‚úÖ All NLTK data successfully downloaded/verified.")
    else:
        print("‚ÑπÔ∏è  Skipping NLTK data management as NLTK is not required in requirements.json.")
        
    # 4. Final Functionality Verification
    print("üîç Performing final functionality verification...")
    try:
        from nltk.stem.porter import PorterStemmer
        stemmer = PorterStemmer()
        test_result = stemmer.stem("running")
        if test_result != "run":
            raise Exception(f"Unexpected stemming result: '{test_result}' != 'run'")
        print("‚úÖ Core NLTK Stemmer functionality verified.")
    except Exception as e:
        print(f"‚ùå FATAL: NLTK functionality test failed: {e}")
        print("   This indicates a broken installation that cannot be used.")
        sys.exit(1)
        
    # 5. Installation Summary
    if final_exit_code == 0:
        print("\nüéâ Installation completed successfully!")
        print("   All dependencies are properly installed and functional.")
    elif final_exit_code == 2:
        print("\n‚ö†Ô∏è  Installation completed with warnings.")
        print("   Core functionality is available, but some optional features may be limited.")
    
    # Exit with the appropriate code (0 = success, 2 = warnings, 1 = fatal error)
    sys.exit(final_exit_code)